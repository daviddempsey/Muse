/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import * as legacy from '@firebase/firestore-types';
import * as exp from '../index';
import { FieldPath as FieldPathExp, Bytes as BytesExp } from '../../exp/index';
import { Compat } from '../../src/compat/compat';
import { Firestore, DocumentReference, DocumentSnapshot, QuerySnapshot } from '../../src/api/database';
export { GeoPoint, Timestamp } from '../index';
export declare class Transaction extends Compat<exp.Transaction> implements legacy.Transaction {
    private readonly _firestore;
    constructor(_firestore: Firestore, delegate: exp.Transaction);
    get<T>(documentRef: DocumentReference<T>): Promise<DocumentSnapshot<T>>;
    set<T>(documentRef: DocumentReference<T>, data: T, options?: legacy.SetOptions): Transaction;
    update(documentRef: DocumentReference<any>, data: legacy.UpdateData): Transaction;
    update(documentRef: DocumentReference<any>, field: string | FieldPath, value: any, ...moreFieldsAndValues: any[]): Transaction;
    delete(documentRef: DocumentReference<any>): Transaction;
}
export declare class WriteBatch extends Compat<exp.WriteBatch> implements legacy.WriteBatch {
    set<T>(documentRef: DocumentReference<T>, data: T, options?: legacy.SetOptions): WriteBatch;
    update(documentRef: DocumentReference<any>, data: legacy.UpdateData): WriteBatch;
    update(documentRef: DocumentReference<any>, field: string | FieldPath, value: any, ...moreFieldsAndValues: any[]): WriteBatch;
    delete(documentRef: DocumentReference<any>): WriteBatch;
    commit(): Promise<void>;
}
export declare class Query<T = legacy.DocumentData> extends Compat<exp.Query<T>> implements legacy.Query<T> {
    readonly firestore: Firestore;
    constructor(firestore: Firestore, delegate: exp.Query<T>);
    where(fieldPath: string | FieldPath, opStr: legacy.WhereFilterOp, value: any): Query<T>;
    orderBy(fieldPath: string | FieldPath, directionStr?: legacy.OrderByDirection): Query<T>;
    limit(n: number): Query<T>;
    limitToLast(n: number): Query<T>;
    startAt(...args: any[]): Query<T>;
    startAfter(...args: any[]): Query<T>;
    endBefore(...args: any[]): Query<T>;
    endAt(...args: any[]): Query<T>;
    isEqual(other: legacy.Query<T>): boolean;
    get(options?: legacy.GetOptions): Promise<QuerySnapshot<T>>;
    onSnapshot(observer: {
        next?: (snapshot: QuerySnapshot<T>) => void;
        error?: (error: legacy.FirestoreError) => void;
        complete?: () => void;
    }): () => void;
    onSnapshot(options: legacy.SnapshotListenOptions, observer: {
        next?: (snapshot: QuerySnapshot<T>) => void;
        error?: (error: legacy.FirestoreError) => void;
        complete?: () => void;
    }): () => void;
    onSnapshot(onNext: (snapshot: QuerySnapshot<T>) => void, onError?: (error: legacy.FirestoreError) => void, onCompletion?: () => void): () => void;
    onSnapshot(options: legacy.SnapshotListenOptions, onNext: (snapshot: QuerySnapshot<T>) => void, onError?: (error: legacy.FirestoreError) => void, onCompletion?: () => void): () => void;
    withConverter<U>(converter: legacy.FirestoreDataConverter<U>): Query<U>;
}
export declare class CollectionReference<T = legacy.DocumentData> extends Query<T> implements legacy.CollectionReference<T> {
    readonly firestore: Firestore;
    readonly _delegate: exp.CollectionReference<T>;
    constructor(firestore: Firestore, _delegate: exp.CollectionReference<T>);
    readonly id: string;
    readonly path: string;
    get parent(): DocumentReference<legacy.DocumentData> | null;
    doc(documentPath?: string): DocumentReference<T>;
    add(data: T): Promise<DocumentReference<T>>;
    isEqual(other: CollectionReference<T>): boolean;
    withConverter<U>(converter: legacy.FirestoreDataConverter<U>): CollectionReference<U>;
}
export declare class FieldPath extends Compat<FieldPathExp> implements legacy.FieldPath {
    constructor(...fieldNames: string[]);
    static documentId(): FieldPath;
    isEqual(other: FieldPath): boolean;
}
export declare class Blob extends Compat<BytesExp> implements legacy.Blob {
    static fromBase64String(base64: string): Blob;
    static fromUint8Array(array: Uint8Array): Blob;
    toBase64(): string;
    toUint8Array(): Uint8Array;
    isEqual(other: Blob): boolean;
}
